#!/usr/bin/env python3
"""
cleanup_dfs.py - A script to clean up text files by applying multiple normalization steps.

This script reads an input text file and cleans it by performing several operations such as:
    - Trimming leading and trailing whitespace.
    - Collapsing extra whitespace (spaces, tabs, newlines) into a single space.
    - Removing HTML/XML tags.
    - Removing URLs.
    - Removing email addresses.
    - Removing non-ASCII characters.
    - Normalizing punctuation (e.g., reducing multiple exclamation marks to one).
    - Normalizing case.
    - Removing special characters.
    - Removing boilerplate phrases.

The output file is generated by appending '_cleanup' to the input file's base name while preserving the extension.

Usage:
    python3 cleanup_dfs.py --input <filename>

Example:
    If you have a file named 'dfs.txt', running:
        python3 cleanup_dfs.py --input dfs.txt
    will create an output file named 'dfs_cleanup.txt'.
"""

import argparse
import re
import os
import logging
import sys
from typing import NoReturn, List

# ------------------------------------------------------------------------------
# Custom Argument Parser to Include Example in Error Message
# ------------------------------------------------------------------------------
class CustomArgumentParser(argparse.ArgumentParser):
    def error(self, message: str) -> None:
        sys.stderr.write(self.format_usage())
        if self.epilog:
            sys.stderr.write("\n" + self.epilog + "\n")
        sys.stderr.write(f"{self.prog}: error: {message}\n")
        sys.exit(2)

# ------------------------------------------------------------------------------
# Cleanup Configuration Options (set to False to disable any step)
# ------------------------------------------------------------------------------
TRIM_WHITESPACE: bool = True
COLLAPSE_WHITESPACE: bool = True
REMOVE_HTML: bool = True
REMOVE_URLS: bool = True
REMOVE_EMAILS: bool = True
REMOVE_NON_ASCII: bool = True
NORMALIZE_PUNCTUATION: bool = True
NORMALIZE_CASE: bool = True
REMOVE_SPECIAL_CHARACTERS: bool = True  # Change to False if not needed
REMOVE_BOILERPLATE: bool = True         # Change to False if not needed

# List of boilerplate phrases to remove if REMOVE_BOILERPLATE is enabled
BOILERPLATE_PHRASES: List[str] = ["DataFromSky"]

# ------------------------------------------------------------------------------
# Logging Configuration
# ------------------------------------------------------------------------------
logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")

# ------------------------------------------------------------------------------
# Helper Cleanup Functions
# ------------------------------------------------------------------------------

def remove_html(text: str) -> str:
    """Remove HTML or XML tags from the text."""
    return re.sub(r'<[^>]+>', ' ', text)

def remove_urls(text: str) -> str:
    """Remove URLs from the text."""
    return re.sub(r'https?://\S+|www\.\S+', ' ', text)

def remove_emails(text: str) -> str:
    """Remove email addresses from the text."""
    return re.sub(r'\S+@\S+', ' ', text)

def remove_non_ascii(text: str) -> str:
    """Remove non-ASCII characters from the text."""
    return text.encode('ascii', 'ignore').decode('ascii')

def normalize_punctuation(text: str) -> str:
    """Replace multiple punctuation marks with a single one."""
    # Example: reduce multiple exclamation or question marks to a single mark.
    return re.sub(r'([!?]){2,}', r'\1', text)

def collapse_whitespace(text: str) -> str:
    """Collapse multiple whitespace characters into a single space."""
    return re.sub(r'\s+', ' ', text)

def normalize_case(text: str) -> str:
    """Convert text to lowercase."""
    return text.lower()

def remove_special_characters(text: str) -> str:
    """Remove special characters, keeping only alphanumeric and common punctuation."""
    return re.sub(r'[^\w\s.,;:!?\'"-]', ' ', text)

def remove_boilerplate(text: str) -> str:
    """Remove known boilerplate phrases from the text."""
    lines = text.splitlines()
    filtered_lines = [line for line in lines if all(bp not in line for bp in BOILERPLATE_PHRASES)]
    return "\n".join(filtered_lines)

# ------------------------------------------------------------------------------
# Main Cleanup Pipeline Function
# ------------------------------------------------------------------------------

def clean_text(text: str) -> str:
    """
    Cleans up the input text by applying several configurable normalization steps.
    
    Args:
        text (str): The raw text to be cleaned.
    
    Returns:
        str: The cleaned text.
    """
    logging.info("Starting text cleanup.")
    
    # 1. Trim leading/trailing whitespace if enabled.
    if TRIM_WHITESPACE:
        logging.info("Trimming leading and trailing whitespace...")
        text = text.strip()
    
    # 2. Remove HTML/XML tags if enabled.
    if REMOVE_HTML:
        logging.info("Removing HTML tags...")
        text = remove_html(text)
    
    # 3. Remove URLs if enabled.
    if REMOVE_URLS:
        logging.info("Removing URLs...")
        text = remove_urls(text)
    
    # 4. Remove email addresses if enabled.
    if REMOVE_EMAILS:
        logging.info("Removing email addresses...")
        text = remove_emails(text)
    
    # 5. Remove non-ASCII characters if enabled.
    if REMOVE_NON_ASCII:
        logging.info("Removing non-ASCII characters...")
        text = remove_non_ascii(text)
    
    # 6. Remove special characters if enabled.
    if REMOVE_SPECIAL_CHARACTERS:
        logging.info("Removing special characters...")
        text = remove_special_characters(text)
    
    # 7. Normalize punctuation if enabled.
    if NORMALIZE_PUNCTUATION:
        logging.info("Normalizing punctuation...")
        text = normalize_punctuation(text)
    
    # 8. Collapse multiple whitespace characters if enabled.
    if COLLAPSE_WHITESPACE:
        logging.info("Collapsing multiple whitespace characters...")
        text = collapse_whitespace(text)
    
    # 9. Normalize case if enabled.
    if NORMALIZE_CASE:
        logging.info("Normalizing case...")
        text = normalize_case(text)
    
    # 10. Remove boilerplate text if enabled.
    if REMOVE_BOILERPLATE:
        logging.info("Removing boilerplate text...")
        text = remove_boilerplate(text)
    
    logging.info("Text cleanup complete.")
    return text

# ------------------------------------------------------------------------------
# Filename Handling and Main Routine
# ------------------------------------------------------------------------------

def generate_output_filename(input_filename: str) -> str:
    """
    Generates an output filename by appending '_cleanup' to the base name while preserving the extension.
    
    Args:
        input_filename (str): The input filename.
    
    Returns:
        str: The generated output filename.
    """
    base, ext = os.path.splitext(input_filename)
    output_filename = f"{base}_cleanup{ext}"
    return output_filename

def main(input_file: str) -> NoReturn:
    """
    Reads an input file, cleans its content using the configurable cleanup options, 
    and writes the cleaned text to a new file with '_cleanup' appended to the original filename.
    
    Args:
        input_file (str): The path to the input file.
    """
    logging.info(f"Reading input file: {input_file}")
    try:
        with open(input_file, "r", encoding="utf-8") as f:
            raw_text = f.read()
    except FileNotFoundError:
        logging.error(f"File not found: {input_file}")
        exit(1)
    except Exception as e:
        logging.error(f"Error reading file {input_file}: {e}")
        exit(1)
    
    cleaned_text = clean_text(raw_text)
    output_file = generate_output_filename(input_file)
    logging.info(f"Writing cleaned text to output file: {output_file}")
    
    try:
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(cleaned_text)
    except Exception as e:
        logging.error(f"Error writing to file {output_file}: {e}")
        exit(1)
    
    logging.info("Cleanup complete.")

if __name__ == "__main__":
    parser = CustomArgumentParser(
        description="Clean up text by applying multiple normalization steps.",
        epilog="example: python3 1_cleanup.py --input dfs.txt"
    )
    parser.add_argument(
        "--input",
        required=True,
        help="Path to the input text file."
    )
    args = parser.parse_args()
    main(args.input)